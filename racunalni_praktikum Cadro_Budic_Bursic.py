# -*- coding: utf-8 -*-
"""racunalni_praktikum.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JsBzFGDEaYYlxNpo2RHw8eaieO4e21GL
"""

"""
This is a solution to a simple regression problem (supervised learning).
Dataset has over than 20 years of data of currency value fluctuation.
In this code we used common python (numpy, pandas, matplotlib) and ML (tensorflow) modules such as tensorflow.
Solution is taking a sequence of 4 consecutive day values of "Australian dollar" 
and calculating the predicted value for 5th day. 
There is a plot of MSE (Mean Squared Error) and RMSE (Root Mean Squared Error) for this model.
At the end we also implemented a GUI for visual refference.
"""
# importig libaries
import numpy as np
import pandas as pd

# reading a file with dataset 
# before using a program change the dataset path accordingly
data = pd.read_csv('/Users/In≈æenjer/Desktop/racunalni praktikum/seminar/currency_exchange_rates_02-01-1995_-_02-05-2018.csv')

# Preparing data for training
data = data["Australian Dollar"]
data = data.dropna()
data = data.reset_index()
data = data.drop("index", axis=1)

#creating empty lists
output_data = []
input_data = []

#separating data into utput and input
#4 days are input and 5th is output
for i in range(len(data)-5):
  for j in range(4):
    input_data.append(data.iloc[i+j])

  output_data.append(data.iloc[i+5])

# converting lists into numpy arrays
input_data = np.array(input_data)
output_data = np.array(output_data)

input_data = input_data.reshape(5710, 4)

# splitting data in train and test sets
input_train = input_data[:4568]
input_test = input_data[4568:]
output_train = output_data[:4568]
output_test = output_data[4568:]

# adding dimension for every sample in dataset
input_train = np.expand_dims(input_train, axis=0)
input_train = np.reshape(input_train, (4568,1,4))
input_test = np.expand_dims(input_test, axis=0)
input_test = np.reshape(input_test, (1142,1,4))

# building a model
# importing libaries
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers


# our model will have 3 layers of neurons
# first 2 layers have 64 neurons, and 3rd has 1 as there is 1 output
model = keras.Sequential(
    [
        layers.Dense(64, input_shape=(1,4), activation="relu"),
        layers.Dense(64, activation="relu"),
        layers.Dense(1),
    ]
)

# compiling model
model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.001), # or "adam"
              loss='mean_squared_error', # or tf.keras.metrics.MeanSquaredError()
              metrics=[tf.keras.metrics.MeanSquaredError(),
                       tf.keras.metrics.RootMeanSquaredError()],
              )

# fitting model
history = model.fit(input_train, output_train, batch_size=50, epochs=10)

# model evaluation
model.evaluate(input_test, output_test)

# plot of loss function and metric
import matplotlib.pyplot as plt
# Plot the loss and metrics over time
plt.plot(history.history['loss'], label="mse (loss)")
plt.plot(history.history['root_mean_squared_error'], label="rmse (metric)")
#titling plot
plt.title('Model history')
plt.legend()
#lableing plot
plt.xlabel('Epoch')
plt.ylabel('Value')
plt.show()


#creating window

import tkinter as tk
window=tk.Tk()
window.title("Gui")


# creating input labels
input1_label=tk.Label(window,text="1st entry")
input1_label.pack()
input1=tk.Entry(window)
input1.pack()

input2_label=tk.Label(window,text="2nd entry")
input2_label.pack()
input2=tk.Entry(window)
input2.pack()

input3_label=tk.Label(window,text="3rd entry")
input3_label.pack()
input3=tk.Entry(window)
input3.pack()

input4_label=tk.Label(window,text="4th entry")
input4_label.pack()
input4=tk.Entry(window)
input4.pack() 



# function for calculating a simple output
def calculate_result():
    
    days_input = []



    days_input.append(input1.get())
    days_input.append(input2.get())
    days_input.append(input3.get())
    days_input.append(input4.get())

    for i in range(4):
       
        days_input[i] = float(days_input[i])

    days_input = np.array(days_input)
    days_input = np.reshape(days_input, (1,4))
    days_input = np.expand_dims(days_input, axis=0)
    
    
#assosiating predictioon with model.predict(days_input)
    prediction = model.predict(days_input)
    prediction = str(prediction)
    prediction = prediction.lstrip("[")
    prediction = prediction.rstrip("]")
#printing prediction
    output_label=tk.Label(window,text=prediction,bg="gray")
    output_label.pack()
    
# creating a button   
calculate_button=tk.Button(window,text="Calculate",command=calculate_result)
calculate_button.pack()

window.mainloop()
